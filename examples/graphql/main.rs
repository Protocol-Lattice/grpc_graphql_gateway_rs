// @generated by protoc-gen-graphql-template
// Source files:
//   - greeter.proto
//
// This is a starter gateway. Update endpoint URLs and tweak as needed.

use grpc_graphql_gateway::{Gateway, GatewayBuilder, GrpcClient, Result as GatewayResult};
use std::net::SocketAddr;
use std::pin::Pin;
use tonic::{transport::Server, Request, Response, Status};
use tracing_subscriber::prelude::*;

type ServiceResult<T> = std::result::Result<T, Status>;

const DESCRIPTOR_SET: &[u8] = include_bytes!("./greeter_descriptor.bin");

fn describe(list: &[&str]) -> String {
    if list.is_empty() { "none".to_string() } else { list.join(", ") }
}

const QUERIES: &[&str] = &["hello"];
const MUTATIONS: &[&str] = &["updateGreeting", "uploadAvatar", "uploadAvatars"];
const SUBSCRIPTIONS: &[&str] = &["streamHello"];

pub mod greeter {
    include!("./greeter.rs");
}

use greeter::greeter_server::{Greeter, GreeterServer};

pub struct ServiceConfig {
    pub name: &'static str,
    pub endpoint: &'static str,
    pub insecure: bool,
    pub queries: &'static [&'static str],
    pub mutations: &'static [&'static str],
    pub subscriptions: &'static [&'static str],
    pub resolvers: &'static [&'static str],
}

pub mod services {
    use super::ServiceConfig;

    pub const GREETER_GREETER: ServiceConfig = ServiceConfig {
        name: "greeter.Greeter",
        endpoint: "http://127.0.0.1:50051",
        insecure: true,
        queries: &["hello"],
        mutations: &["updateGreeting", "uploadAvatar", "uploadAvatars"],
        subscriptions: &["streamHello"],
        resolvers: &["user"],
    };

    pub const ALL: &[ServiceConfig] = &[
        GREETER_GREETER,
    ];
}

/// Scaffolding for gRPC service implementations.
#[derive(Default, Clone)]
pub struct ServiceImpl;

#[tonic::async_trait]
impl greeter::greeter_server::Greeter for ServiceImpl {
    type StreamHellosStream = Pin<Box<dyn futures::Stream<Item = ServiceResult<greeter::HelloReply>> + Send>>;
    async fn say_hello(&self, _request: Request<greeter::HelloRequest>) -> ServiceResult<Response<greeter::HelloReply>> {
        Err(Status::unimplemented("method not implemented"))
    }
    async fn update_greeting(&self, _request: Request<greeter::UpdateGreetingRequest>) -> ServiceResult<Response<greeter::HelloReply>> {
        Err(Status::unimplemented("method not implemented"))
    }
    async fn stream_hellos(&self, _request: Request<greeter::HelloRequest>) -> ServiceResult<Response<Self::StreamHellosStream>> {
        Err(Status::unimplemented("method not implemented"))
    }
    async fn resolve_user(&self, _request: Request<greeter::GetUserRequest>) -> ServiceResult<Response<greeter::User>> {
        Err(Status::unimplemented("method not implemented"))
    }
    async fn upload_avatar(&self, _request: Request<greeter::UploadAvatarRequest>) -> ServiceResult<Response<greeter::UploadAvatarReply>> {
        Err(Status::unimplemented("method not implemented"))
    }
    async fn upload_avatars(&self, _request: Request<greeter::UploadAvatarsRequest>) -> ServiceResult<Response<greeter::UploadAvatarsReply>> {
        Err(Status::unimplemented("method not implemented"))
    }
}

pub async fn run_services() -> GatewayResult<()> {
    let addr: SocketAddr = "0.0.0.0:50051"
        .parse()
        .map_err(|e| grpc_graphql_gateway::Error::Other(anyhow::Error::new(e)))?;
    let service = ServiceImpl::default();
    tracing::info!("gRPC services listening on {}", addr);
    Server::builder()
        .add_service(greeter::greeter_server::GreeterServer::new(service.clone()))
        .serve(addr)
        .await?;
    Ok(())
}

pub fn gateway_builder() -> GatewayResult<GatewayBuilder> {
    // The descriptor set is produced by your build.rs using tonic-build.
    let mut builder = Gateway::builder()
        .with_descriptor_set_bytes(DESCRIPTOR_SET);

    // Add gRPC backends for each service discovered in your protos.
    for svc in services::ALL {
        tracing::info!(
            "{svc} -> {endpoint} (queries: {queries}; mutations: {mutations}; subscriptions: {subscriptions}; resolvers: {resolvers})",
            svc = svc.name,
            endpoint = svc.endpoint,
            queries = describe(svc.queries),
            mutations = describe(svc.mutations),
            subscriptions = describe(svc.subscriptions),
            resolvers = describe(svc.resolvers),
        );
        let client = GrpcClient::builder(svc.endpoint)
            .insecure(svc.insecure)
            .lazy(true)
            .connect_lazy()?;
        builder = builder.add_grpc_client(svc.name, client);
    }

    // Update the endpoints above to point at your actual services.

    Ok(builder)
}

#[tokio::main]
async fn main() -> GatewayResult<()> {
    // Basic logging; adjust as desired.
    tracing_subscriber::registry()
        .with(tracing_subscriber::fmt::layer())
        .init();

    tracing::info!(
        "GraphQL operations -> queries: {queries}; mutations: {mutations}; subscriptions: {subscriptions}",
        queries = describe(QUERIES),
        mutations = describe(MUTATIONS),
        subscriptions = describe(SUBSCRIPTIONS),
    );

    // NOTE: Resolver entries are listed above; the runtime currently warns that they are not implemented.
    // Uncomment to run the services in the same process:
    tokio::spawn(async { run_services().await.unwrap(); });

    gateway_builder()?
        .serve("0.0.0.0:8888")
        .await
}
