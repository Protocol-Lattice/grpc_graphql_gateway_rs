// This file is @generated by prost-build.
/// Extend ServiceOptions in order to define grpc connection setting.
/// User can use this option as following:
///
/// service Greeter {
///     option (graphql.service) = {
///       host: "localhost:50051" // define grpc connection host and port
///       insecure: true          // set true if connect to insecure grpc server
///     };
///
///     ... some rpc definitions
/// }
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GraphqlService {
    /// gRPC default connection host.
    /// This value should include host and port, say localhost:50051.
    #[prost(string, tag = "1")]
    pub host: ::prost::alloc::string::String,
    /// If true, automatic connection with insecure option.
    #[prost(bool, tag = "2")]
    pub insecure: bool,
}
/// Extend MethodOptions in order to define GraphQL Query or Mutation.
/// User can use this option as following:
///
/// service Greeter {
///     rpc SayHello(HelloRequest) returns (HelloReply) {
///       option (graphql.schema) = {
///         type: QUERY    // declare as Query
///         name: "hello"  // query name
///       }
///     }
/// }
///
/// Since gRPC reason, it has limitation that the response could not be repeated.
/// it's dificcurl to respond array response, so that we accept "response.pluck"
/// in order to expose repeated fields in response message.
///
/// For instance:
///
/// message Member {
///    string name = 1;
/// }
///
/// message ListMembersResponse {
///    repeated Member members = 1; -- could be array response
/// }
///
/// message ListMembersRequest {
/// }
///
/// service MemberService {
///     rpc ListMembers(ListMembersRequest) returns (ListMembersResponse) {
///       option (graphql.schema) = {
///         type: QUERY
///         name: "members"
///         response {
///           repeated : true
///           pluck: "members" // Query will respond \[Member\] instead of ListMembersResponse
///         }
///       }
///     }
/// }
///
/// In mutation declaration:
///
/// service MemberService {
///     rpc CreateMember(CreateMemberRequest) returns (Member) {
///       option (graphql.schema) = {
///         type: MUTATION        // declare as Mutation
///         name: "cretemember"   // mutation name
///       }
///     }
/// }
///
/// The Mutation's input always becomes an input object, so you need to declare argument name.
///
/// message Member {
///    string name = 1;
/// }
///
/// message CreateMemberRequest {
///    string name = 1;
/// }
///
/// service MemberService {
///     rpc CreateMember(CreateMemberRequest) returns (Member) {
///       option (graphql.schema) = {
///         type: MUTATION
///         name: "createmember"
///         request {
///           name: "member" // this is equivalent to createbook(member: Member): Member in GraphQL
///         }
///       }
///     }
/// }
///
/// Finally, user can access this query via /graphql?query={members{name}}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GraphqlSchema {
    /// graphql type. Enum of QUERY or MUTATION is valid value
    #[prost(enumeration = "GraphqlType", tag = "1")]
    pub r#type: i32,
    /// query name. this field is required
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Query request object configuration
    #[prost(message, optional, tag = "3")]
    pub request: ::core::option::Option<GraphqlRequest>,
    /// Query response object configuration
    #[prost(message, optional, tag = "4")]
    pub response: ::core::option::Option<GraphqlResponse>,
}
/// configuration option for request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GraphqlRequest {
    /// Define input name.
    /// This field enables only for mutation and note that if this field is specified,
    /// the gRPC request message will be dealt with an input.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Define pluck message fields
    #[prost(string, repeated, tag = "2")]
    pub plucks: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// configuration option for response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GraphqlResponse {
    /// If true, this response object is required
    /// But when you declare "pluck", we respect expose field definition.
    #[prost(bool, tag = "1")]
    pub required: bool,
    /// Define pluck message field.
    /// Note that this field IS NOT repeated, just single string field.
    /// It means the response could only be single.
    #[prost(string, tag = "2")]
    pub pluck: ::prost::alloc::string::String,
}
/// GraphqlField is FieldOptions in protobuf in order to define type field attribute.
/// User can use this option as following:
///
/// message Member {
///    string name = 1 \[(graphql.field) = {required: true}\]; // this field is required in GraphQL, it equivalent to String! on GraphQL
/// }
///
/// message CreateMemberRequest {
///    string name = 1; \[(grahpql.field) = {default: "anonymous"}\]; // use default value on input or query
/// }
///
/// Note that in protobuf, all fields are dealt with optional
/// so the same as it, all GraphQL fields are optional as default.
/// If you need to be required, use 'required: true' option
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GraphqlField {
    /// If true, this field is required.
    #[prost(bool, tag = "1")]
    pub required: bool,
    /// Use as other field name (not recommend)
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Define default value on input.
    #[prost(string, tag = "3")]
    pub default: ::prost::alloc::string::String,
    /// Omit this field from graphql definition
    #[prost(bool, tag = "4")]
    pub omit: bool,
    /// Resolve this field by nested query with additional RPC
    #[prost(string, tag = "5")]
    pub resolver: ::prost::alloc::string::String,
    /// Federation: Mark this field as external (part of another service's entity)
    #[prost(bool, tag = "6")]
    pub external: bool,
    /// Federation: Specify fields this field requires from other services
    #[prost(string, tag = "7")]
    pub requires: ::prost::alloc::string::String,
    /// Federation: Specify fields this field provides to the supergraph
    #[prost(string, tag = "8")]
    pub provides: ::prost::alloc::string::String,
}
/// Federation configuration for message types (entities).
/// User can use this option to define federated entities:
///
/// message User {
///    option (graphql.entity) = {
///      keys: "id"
///      keys: "email"
///    };
///    string id = 1;
///    string email = 2;
///    string name = 3;
/// }
///
/// For extending entities from another service:
///
/// message Product {
///    option (graphql.entity) = {
///      extend: true
///      keys: "upc"
///    };
///    string upc = 1 \[(graphql.field) = {external: true}\];
///    int32 stock = 2;
/// }
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GraphqlEntity {
    /// List of key fields or field sets that uniquely identify this entity
    /// Each key can be a single field name or a field set like "id email"
    #[prost(string, repeated, tag = "1")]
    pub keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// If true, this message extends an entity defined in another service
    #[prost(bool, tag = "2")]
    pub extend: bool,
    /// If specified, this service will be resolvable (implements _entities resolver)
    #[prost(bool, tag = "3")]
    pub resolvable: bool,
}
/// explicit schema declaration enum
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GraphqlType {
    /// schema will generate as Query
    Query = 0,
    /// schema will generate as Mutation
    Mutation = 1,
    /// schema will generate as Resolver. Resolver behaves not listed in query, but can resolve nested field.
    Resolver = 2,
    /// schema will generate Subscription.
    Subscription = 3,
}
impl GraphqlType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Query => "QUERY",
            Self::Mutation => "MUTATION",
            Self::Resolver => "RESOLVER",
            Self::Subscription => "SUBSCRIPTION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "QUERY" => Some(Self::Query),
            "MUTATION" => Some(Self::Mutation),
            "RESOLVER" => Some(Self::Resolver),
            "SUBSCRIPTION" => Some(Self::Subscription),
            _ => None,
        }
    }
}
